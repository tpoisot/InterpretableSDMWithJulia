{
  "hash": "6bab5a1c13542ef99e9688420c56da3d",
  "result": {
    "markdown": "---\ntitle: \"Building an interpretable SDM from scratch\"\nsubtitle: \"using Julia 1.9\"\nauthor:\n    name: \"TimothÃ©e Poisot\"\n    email: timothee.poisot@umontreal.ca\ninstitute: \"UniversitÃ© de MontrÃ©al\"\ntitle-slide-attributes: \n  data-background-image: https://cdn.pixabay.com/photo/2019/08/16/23/02/white-breasted-nuthatch-4411169_960_720.jpg\n  data-background-opacity: \"0.15\"\nbibliography: references.bib\ncsl: https://www.zotero.org/styles/ecology-letters\n---\n\n## Overview\n\n-   Build a *simple* classifier to predict the distribution of a species\n\n-   Use this as an opportunity to talk about interpretable ML\n\n-   Discuss which biases are appropriate in a predictive model\n\n::: footer\nCC BY 4.0 - TimothÃ©e Poisot\n:::\n\n------------------------------------------------------------------------\n\n::: r-fit-text\nWe care a lot about the\n\n**process**\n\nand only a little about the\n\n**product**\n:::\n\n------------------------------------------------------------------------\n\n## Raccoons!\n\n-   Relatable (bag under eyes, love naps, out of shape)\n\n-   High volume of data\n\n-   Species of concern for zoonotic diseases\n\n-   Where can we find them in/around QuÃ©bec?\n\n::: footer\nSee also @higino2021 for more quality ðŸ¦ content\n:::\n\n## Do try this at home!\n\nðŸ’» + ðŸ“” + ðŸ—ºï¸ at `https://github.com/tpoisot/InterpretableSDMWithJulia/`\n\n::: {#include-the-packages-we-need .cell execution_count=1}\n``` {.julia .cell-code}\ninclude(joinpath(\"code\", \"pkg.jl\")); # Dependencies\ninclude(joinpath(\"code\", \"nbc.jl\")); # Naive Bayes Classifier\ninclude(joinpath(\"code\", \"bioclim.jl\")); # BioClim model\ninclude(joinpath(\"code\", \"confusion.jl\")); # Confusion matrix utilities\ninclude(joinpath(\"code\", \"splitters.jl\")); # Cross-validation\ninclude(joinpath(\"code\", \"crossvalidate.jl\")); # Cross-validation\ninclude(joinpath(\"code\", \"variableselection.jl\")); # Variable selection\ninclude(joinpath(\"code\", \"shapley.jl\")); # Shapley values\ninclude(joinpath(\"code\", \"palettes.jl\")); # Color palettes\n```\n:::\n\n\n## To train a model, we need...\n\nA response variable $y$\n\n:   presence or absence of a species at a location identified by its latitude and longitude\n\nA series of predictors $\\mathbf{x}$\n\n:   bioclimatic variables\n\nA series of predictions $\\hat y$\n\n:   which we will compare to the values of $y$\n\n## Species occurrence filtering\n\nWe use the [GBIF] API through the `GBIF` package to get data about *Procyon lotor*\n\n  [GBIF]: http://gbif.org\n\n::: {#get-the-species-from-the-github-file .cell execution_count=2}\n``` {.julia .cell-code}\nif ~isfile(\"occurrences.csv\")\n    Downloads.download(\"https://gist.githubusercontent.com/tpoisot/e01313c366cc845778e973441e7d4db7/raw/85cf9f4a753c159f54a0fb51bf8ac4c854a8819a/bigfoot.csv\", \"occurrences.csv\")\nend\nsightings = CSV.File(\"occurrences.csv\")\nboundingbox = (\n    left = minimum(sightings.Longitude),\n    right = maximum(sightings.Longitude),\n    bottom = minimum(sightings.Latitude),\n    top = maximum(sightings.Latitude),\n)\n```\n:::\n\n\n::: footer\nSee @dansereau2021 for more about these packages\n:::\n\n\n## Bioclimatic data\n\nWe collect BioClim data from CHELSA v1, using `SpeciesDistributionToolkit`\n\n::: {#download-the-bioclim-data-from-worldclim2 .cell execution_count=3}\n``` {.julia .cell-code}\nprovider = RasterData(WorldClim2, BioClim)\nopts = (; resolution=10.0)\ntemperature = SimpleSDMPredictor(provider, layer=1; opts..., boundingbox...)\n```\n:::\n\n\n::: footer\nBioClim data from @karger2020\n:::\n\n## Where are we so far?\n\n::: {#74c15b84 .cell execution_count=4}\n\n::: {.cell-output .cell-output-display execution_count=44}\n![](slides_files/figure-revealjs/cell-5-output-1.png){}\n:::\n:::\n\n\n## Spatial thinning\n\nWe limit the occurrences to one per grid cell, assigned to the center of the grid cell\n\n::: {#make-the-layer-for-presences .cell execution_count=5}\n``` {.julia .cell-code}\npresence_layer = similar(temperature, Bool)\nfor i in axes(sightings, 1)\n    presence_layer[sightings.Longitude[i], sightings.Latitude[i]] = true\nend\n```\n:::\n\n\n## Background points generation\n\nWe generate background points proportionally to the distance away from observations, with a 10km buffer around each point with no background point allowed:\n\n::: {#make-the-pseudo-absence-buffer .cell execution_count=6}\n``` {.julia .cell-code}\npossible_background = pseudoabsencemask(DistanceToEvent, presence_layer)\n```\n:::\n\n\nAnd then we sample one pseudo-absence for each occurrence:\n\n::: {#make-the-absence-layer .cell execution_count=7}\n``` {.julia .cell-code}\nabsence_layer = backgroundpoints(\n    (x -> x^1.05).(possible_background), \n    3sum(presence_layer);\n    replace=false\n)\n```\n:::\n\n\n::: footer\nSee @barbet-massin2012 for more on background points\n:::\n\n## Background points cleaning\n\nWe can remove all of the information that is neither a presence nor a pseudo-absence\n\n::: {#pseudo-absencepresence-remove .cell execution_count=8}\n``` {.julia .cell-code}\nreplace!(absence_layer, false => nothing)\nreplace!(presence_layer, false => nothing)\n```\n:::\n\n\n## Data overview\n\n::: {#9030aabe .cell execution_count=9}\n\n::: {.cell-output .cell-output-display execution_count=49}\n![](slides_files/figure-revealjs/cell-10-output-1.png){}\n:::\n:::\n\n\n\n\n## Preparing the responses and variables\n\n::: {#assemble-y-and-x .cell execution_count=11}\n``` {.julia .cell-code}\nXpresence = hcat([bioclim_var[keys(presence_layer)] for bioclim_var in predictors]...)\nypresence = fill(true, length(presence_layer))\nXabsence = hcat([bioclim_var[keys(absence_layer)] for bioclim_var in predictors]...)\nyabsence = fill(false, length(absence_layer))\nX = vcat(Xpresence, Xabsence)\ny = vcat(ypresence, yabsence)\n```\n:::\n\n\n\n\n## The model -- Naive Bayes Classifier\n\nPrediction:\n\n$$\nP(+|x) = \\frac{P(+)}{P(x)}P(x|+)\n$$\n\nDecision rule:\n\n$$\n\\hat y = \\text{argmax}_j \\, P(\\mathbf{c}_j)\\prod_i P(\\mathbf{x}_i|\\mathbf{c}_j)\n$$\n\n::: footer\nWith $n$ instances and $f$ features, NBC trains *and* predicts in $\\mathcal{O}(n\\times f)$\n:::\n\n## The model -- Naive Bayes Classifier\n\nAssumption of Gaussian distributions:\n\n$$\nP(x|+) = \\text{pdf}(x, \\mathcal{N}(\\mu_+, \\sigma_+))\n$$\n\n## Cross-validation\n\nWe keep an **unseen** *testing* set -- this will be used at the very end to report expected model performance\n\n::: {#testing-set .cell execution_count=13}\n``` {.julia .cell-code}\nidx, tidx = holdout(y, X; permute=true)\n```\n:::\n\n\nFor *validation*, we will run k-folds\n\n::: {#k-folds .cell execution_count=14}\n``` {.julia .cell-code}\nty, tX = y[idx], X[idx,:]\nfolds = kfold(ty, tX; k=10, permute=true)\nk = length(folds)\n```\n:::\n\n\n::: footer\nSee @valavi2018 for more on cross-validation\n:::\n\n## A note on cross-validation\n\nAll models share the same folds\n\n:   we can compare the validation performance across experiments to select the best model\n\nModel performance can be compared\n\n:   we average the relevant summary statistics over each validation set\n\nTesting set is *only* for future evaluation\n\n:   we can only use it once and report the expected performance *of the best model*\n\n## Baseline performance\n\nWe need to get a sense of how difficult the classification problem is:\n\n::: {#33ffac86 .cell execution_count=15}\n``` {.julia .cell-code}\nN_v0 = crossvalidate(naivebayes, ty, tX, folds)\nB_v0 = crossvalidate(bioclim, ty, tX, folds, eps())\n```\n:::\n\n\nThis uses an un-tuned model with all variables and reports the average over all validation sets. In addition, we will always use the BioClim model as a comparison.\n\n## Measures on the confusion matrix {.smaller}\n\n|     | BioClim | NBC                                   |\n|-----|----|---------------------------------------|\n| FPR | 0\\.77 Â± 0\\.0 | 0\\.14 Â± 0\\.0 |\n| FNR | 0\\.01 Â± 0\\.0 | 0\\.17 Â± 0\\.0 |\n| TPR | 0\\.99 Â± 0\\.0 | 0\\.83 Â± 0\\.0 |\n| TNR | 0\\.23 Â± 0\\.0 | 0\\.86 Â± 0\\.0 |\n| TSS | 0\\.23 Â± 0\\.0 | 0\\.7 Â± 0\\.0 |\n| MCC | 0\\.26 Â± 0\\.0 | 0\\.65 Â± 0\\.0 |\n\n::: footer\nIt's a good idea to check the values for the training sets too...\n:::\n\n## Variable selection\n\nWe add variables one at a time, until the Matthew's Correlation Coefficient stops increasing -- we keep annual temperature, isothermality, mean diurnal range, and annual precipitation\n\n::: {#cb13a78c .cell execution_count=16}\n``` {.julia .cell-code}\navailable_variables = constrainedselection(ty, tX, folds, naivebayes, mcc, [1,12])\n```\n:::\n\n\nThis method identifies 6 variables, some of which are:\n\n1.  Annual Mean Temperature\n\n2.  Annual Precipitation\n\n3.  Precipitation of Coldest Quarter\n\n## Discuss - can we force variable selection?\n\n-   constrained variable selection\n\n-   VIF + variable selection\n\n-   PCA?\n\n## Model with variable selection\n\n::: {#3c5b120b .cell execution_count=17}\n``` {.julia .cell-code}\nN_v1 = crossvalidate(naivebayes, ty, tX[:,available_variables], folds)\nB_v1 = crossvalidate(bioclim, ty, tX[:,available_variables], folds, eps())\n```\n:::\n\n\n## Measures on the confusion matrix\n\n|     | BioClim | NBC  | BioClim (v.s.) | NBC (v.s.)  |\n|-----|----|-----------|----|-----------|\n| FPR | 0\\.77 Â± 0\\.0 | 0\\.14 Â± 0\\.0 | 0\\.8 Â± 0\\.0 | 0\\.12 Â± 0\\.0 |\n| FNR | 0\\.01 Â± 0\\.0 | 0\\.17 Â± 0\\.0 | 0\\.0 Â± 0\\.0 | 0\\.13 Â± 0\\.0 |\n| TPR | 0\\.99 Â± 0\\.0 | 0\\.83 Â± 0\\.0 | 1\\.0 Â± 0\\.0 | 0\\.87 Â± 0\\.0 |\n| TNR | 0\\.23 Â± 0\\.0 | 0\\.86 Â± 0\\.0 | 0\\.2 Â± 0\\.0 | 0\\.88 Â± 0\\.0 |\n| TSS | 0\\.23 Â± 0\\.0 | 0\\.7 Â± 0\\.0 | 0\\.2 Â± 0\\.0 | 0\\.76 Â± 0\\.0 |\n| MCC | 0\\.26 Â± 0\\.0 | 0\\.65 Â± 0\\.0 | 0\\.24 Â± 0\\.0 | 0\\.71 Â± 0\\.0 |\n\n## How do we make the model better?\n\nThe NBC is a *probabilistic classifier* returning $P(+|\\mathbf{x})$\n\nThe *decision rule* is to assign a presence when $P(\\cdot) > 0.5$\n\nBut $P(\\cdot) > \\tau$ is a far more general approach, and we can use learning curves to identify $\\tau$\n\n## Thresholding the model\n\n::: {#0a2e9129 .cell execution_count=18}\n``` {.julia .cell-code}\nthr = LinRange(0.0, 1.0, 150)\nT = hcat([crossvalidate(naivebayes, ty, tX[:,available_variables], folds, t) for t in thr]...)\n```\n:::\n\n\n## But how do we pick the threshold?\n\n::: {#c6cb7c43 .cell execution_count=19}\n\n::: {.cell-output .cell-output-display execution_count=62}\n![](slides_files/figure-revealjs/cell-20-output-1.svg){}\n:::\n:::\n\n\n## Tuned model with selected variables\n\n::: {#4f16a96d .cell execution_count=20}\n``` {.julia .cell-code}\nN_v2 = crossvalidate(naivebayes, ty, tX[:,available_variables], folds, thr[m])\n```\n:::\n\n\n## Measures on the confusion matrix\n\n|     | BioClim | NBC  | BioClim (v.s.) | NBC (v.s.)  | NBC (v.s. + tuning)  |\n|-----|----|-----------|----|-----------|----|\n| FPR | 0\\.77 Â± 0\\.0 | 0\\.14 Â± 0\\.0 | 0\\.8 Â± 0\\.0 | 0\\.12 Â± 0\\.0 | 0\\.07 Â± 0\\.0 |\n| FNR | 0\\.01 Â± 0\\.0 | 0\\.17 Â± 0\\.0 | 0\\.0 Â± 0\\.0 | 0\\.13 Â± 0\\.0 | 0\\.19 Â± 0\\.0 |\n| TPR | 0\\.99 Â± 0\\.0 | 0\\.83 Â± 0\\.0 | 1\\.0 Â± 0\\.0 | 0\\.87 Â± 0\\.0 | 0\\.81 Â± 0\\.0 |\n| TNR | 0\\.23 Â± 0\\.0 | 0\\.86 Â± 0\\.0 | 0\\.2 Â± 0\\.0 | 0\\.88 Â± 0\\.0 | 0\\.93 Â± 0\\.0 |\n| TSS | 0\\.23 Â± 0\\.0 | 0\\.7 Â± 0\\.0 | 0\\.2 Â± 0\\.0 | 0\\.76 Â± 0\\.0 | 0\\.74 Â± 0\\.0 |\n| MCC | 0\\.26 Â± 0\\.0 | 0\\.65 Â± 0\\.0 | 0\\.24 Â± 0\\.0 | 0\\.71 Â± 0\\.0 | 0\\.73 Â± 0\\.0 |\n\n## Tuned model performance\n\nWe can retrain over *all* the training data\n\n::: {#60996a29 .cell execution_count=21}\n``` {.julia .cell-code}\nfinalmodel = naivebayes(ty, tX[:,available_variables])\nprediction = vec(mapslices(finalmodel, X[tidx,available_variables]; dims=2))\nC = ConfusionMatrix(prediction, y[tidx], thr[m])\n```\n:::\n\n\n## Estimated performance\n\n|     | Final model                        |\n|-----|------------------------------------|\n| FPR | 0\\.07 |\n| FNR | 0\\.2 |\n| TPR | 0\\.8 |\n| TNR | 0\\.93 |\n| MCC | 0\\.74 |\n| MCC | 0\\.74 |\n\n## Acceptable bias\n\n-   false positives: we expect that our knowledge of the distribution is incomplete!\n\n-   false negatives: we used a heuristic for background points!\n\n## Prediction for each pixel\n\n\n\n::: {#4ed0b3c7 .cell execution_count=23}\n``` {.julia .cell-code}\nprediction = similar(first(predictors), Float64)\nThreads.@threads for k in keys(prediction)\n    prediction[k] = finalmodel([p[k] for p in predictors[available_variables]])\n    if isnan(prediction[k])\n        prediction[k] = 0.0\n    end\nend\n```\n:::\n\n\n## Tuned model - prediction\n\n::: {#9089d128 .cell execution_count=24}\n\n::: {.cell-output .cell-output-display execution_count=69}\n![](slides_files/figure-revealjs/cell-25-output-1.png){}\n:::\n:::\n\n\n## Tuned model - uncertainty\n\n::: {#c0e41c1a .cell execution_count=25}\n\n::: {.cell-output .cell-output-display execution_count=70}\n![](slides_files/figure-revealjs/cell-26-output-1.png){}\n:::\n:::\n\n\n::: footer\nIQR for the models trained on each fold\n:::\n\n## Tuned model - entropy\n\n::: {#d8afb3be .cell execution_count=26}\n\n::: {.cell-output .cell-output-display execution_count=71}\n![](slides_files/figure-revealjs/cell-27-output-1.png){}\n:::\n:::\n\n\n::: footer\nEntropy (in bits) of the NBC probability\n:::\n\n## Tuned model - range\n\n::: {#e3b45c68 .cell execution_count=27}\n\n::: {.cell-output .cell-output-display execution_count=72}\n![](slides_files/figure-revealjs/cell-28-output-1.png){}\n:::\n:::\n\n\n::: footer\nProbability \\> 0.752\n:::\n\n## Predicting the predictions?\n\nShapley values (Monte-Carlo approximation): if we mix the variables across two observations, how important is the $i$-th variable?\n\nExpresses \"importance\" as an additive factor on top of the *average* prediction (here: average prob. of occurrence)\n\n::: {#253aa935 .cell execution_count=28}\n``` {.julia .cell-code}\nshapval = [similar(first(predictors), Float64) for i in eachindex(available_variables)]\nThreads.@threads for k in keys(shapval[1])\n    x = [p[k] for p in predictors[available_variables]]\n    for i in axes(shapval, 1)\n        shapval[i][k] = shapleyvalues(finalmodel, tX[:,available_variables], x, i; M=50)\n        if isnan(shapval[i][k])\n            shapval[i][k] = 0.0\n        end\n    end\nend\n```\n:::\n\n\n## Importance of variables\n\n::: {#36e04392 .cell execution_count=29}\n``` {.julia .cell-code}\nvarimp = sum.(map(abs, shapval))\nvarimp ./= sum(varimp)\nfor v in sortperm(varimp, rev=true)\n    vname = variables[available_variables[v]][2]\n    vctr = round(Int, varimp[v]*100)\n    println(\"$(vname) - $(vctr)%\")\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAnnual Mean Temperature - 26%\nPrecipitation of Coldest Quarter - 18%\nIsothermality (BIO2/BIO7) (Ã—100) - 17%\nAnnual Precipitation - 17%\nMean Diurnal Range (Mean of monthly (max temp - min temp)) - 11%\nPrecipitation Seasonality (Coefficient of Variation) - 11%\n```\n:::\n:::\n\n\nThere is a difference between **contributing to model performance** and **contributing to model explainability**\n\n## Top three variables\n\n::: {#6e4c7648 .cell execution_count=30}\n\n::: {.cell-output .cell-output-display execution_count=76}\n![](slides_files/figure-revealjs/cell-31-output-1.png){}\n:::\n:::\n\n\n## Most determinant predictor\n\n::: {#5c12152d .cell execution_count=31}\n\n::: {.cell-output .cell-output-display execution_count=77}\n![](slides_files/figure-revealjs/cell-32-output-1.png){}\n:::\n:::\n\n\n## Take-home\n\n-   building a model is *incremental*\n\n-   each step adds arbitrary decisions we can control for, justify, or live with\n\n-   we can provide explanations for every single prediction\n\n-   free online textbook (in development) at `https://tpoisot.github.io/DataSciForBiodivSci/`\n\n## References\n\n",
    "supporting": [
      "slides_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}